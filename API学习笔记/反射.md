[TOC]

# 反射

## 定义

> 被加载到内存中的字节码文件（==有且只有一份==）的类名的透明操作（想得到类里的任何数据都可以）
>
> 效率相对较低
>
> 反射使用的类：`Class`
>
> 
>
> - 在运行状态中，对于任意一个类，都能获取属性和方法；
>
> - 对于任意一个对象，都可以调用属性和方法；
> - ==我们就把可以动态获取和调用属性和方法的过程，叫反射==
>
> 
>
> 反射在平时写程序的时候，基本不用，通常完成框架
>
> - 特点：使工程更加灵活，效率相对硬编码低



## 获取到Class对象

> ==不管使用哪一种方法获取对象的Class对象，都相等，在内存中有且只有一份==

> 只知道类名的情况下
>
> `Class ** = 类名.class`

```java
		//只知道类名的情况下
		Class clazz = Student.class;
		System.out.println(clazz);
```



> 已知对象，使用对象的getClass()方法，获取Class对象
>
> `Class ** = 对象名.getClass();`

```java
		//已知对象，使用对象的getClass()方法，获取Class对象
		Student stu = new Student();
		Class clazz2 = stu.getClass();
```



> ==框架中最经常用的方法，来获取Class对象==
>
> `Class ** = Class.forName("包名.类名");`
>
> `forName()`获取Class对象：首先检查内存中是否存在字节码文件
>
> - 如果存在，返回Class对象
> - 如果没有加载到内存，那么先加载该类的字节码文件到内存，返回该类的Class对象

```java
		/**
		 * 框架中最经常用的方法，来获取Class对象
		 */
		//forName()获取Class对象：首先检查内存中是否存在字节码文件
		//	如果存在，返回Class对象
		//	如果没有加载到内存，那么先加载该类的字节码文件到内存，返回该类的Class对象
		Class clazz3 = Class.forName("反射.Student");

		System.out.println(clazz2 == clazz3);
```



## 对类的==构造方法==的操作

> 通过反射获取构造方法，使用构造方法创建对象

> 获取所有的非私有的构造方法
>
> `类名.class.getConstructors()`:Constructors[ ]

```java
		//获取所有的非私有的构造方法
		Constructor[] cons = Student.class.getConstructors();
		for(Constructor con : cons) {
			System.out.println(con);
		}
```



> 获取指定的构造方法
>
> - 获取无参的构造方法：
>
>   `类名.class.getConstructor(null);`：Constructor<类名>

```java
		Constructor<Student> con1 = Student.class.getConstructor(null);
		//通过无参的构造方法创建对象
		Student stu1 = con1.newInstance();
		stu1.sleep();
		stu1.name = "admin";
		stu1.eat("苹果");
```

> 获取有参的构造方法：
>
> ​	`Student.class.getConstructor(String.class,int.class);`:参数对应构造方法的参数列表的类型的Class类型
>
> ​	String：String.class
>
> ​	int ：int.class

```java
		//有参的构造方法
		Constructor<Student> con2 = Student.class.getConstructor(String.class,int.class);
		Student stu2 = con2.newInstance("张三",20);
		stu2.eat("包子");
```





## 对类的==成员变量==的操作

> 获取类的所有非私有属性
>
> `getFields()`:Field[ ] 返回所有非私有的成员变量，存在数组中
>
> `getModifiers()`:int 返回成员变量的访问修饰符，public-1
>
> `getName()`:String 返回成员变量的名字
>
> `getType()`:String 返回成员变量的类型（int,String,double……）

```java
		Class clazz = Student.class;
		Student stu = (Student) clazz.newInstance();
		
		//获取类的所有非私有属性
		Field[] fields = clazz.getFields();
		for(Field field : fields) {
			System.out.println(field.getModifiers());
			System.out.println(field.getName());
			System.out.println(field.getType());
		}
```



> 获取指定的属性
>
> `类名.class.getField(String name);`:name为要获取的类的成员变量名，返回类型：Field

```java
		//获取指定的属性
		Field field1 = Student.class.getField("name");
```



> 给属性设置值，获取值
>
> `set(obj,String);`给变量赋值
>
> - obj : 对象名，在该对象的变量中操作属性
> - String ：内容，要设置属性的内容
>
> `get(obj)`获取变量的值
>
> - obj ：要获取该变量的对象

```java
		//给属性设置值，获取值
		field1.set(stu, "张三");
		System.out.println(field1.get(stu));
```



> 获取私有属性，设置值，获取值
>
> `类名.class.getDeclaredField(String name);`获取变量age
>
> `setAccessible(true);`设置私有属性访问权限

```java
		//获取私有属性,设置值，获取值
		Field field2 = Student.class.getDeclaredField("age");
		field2.setAccessible(true);//设置私有属性访问权限
		field2.set(stu, 22);
		System.out.println(field2.get(stu));
```



## 对类的==工具方法==的操作

> 获取所有的非私有成员方法
>
> `类名.class.getMethods();`: Method[ ]
>
> - 将类中所有的非私有方法返回到一个Method类型的数组中
>
> `getModifiers()`：int 获取方法的访问修饰符
>
> `getReturnType()`：String  获取方法的返回类型
>
> `getName()`：String   获取方法的名字

```java
		Class clazz = Student.class;
		//获取所有的非私有成员方法
		Method[] methods = clazz.getMethods();
		for(Method method:methods) {
			System.out.print(method.getModifiers()+"\t");
			System.out.print(method.getReturnType()+"\t");
			System.out.println(method.getName());
		}
```



> 获取指定的成员方法
>
> `类名.class.getMethod(String name,Class parameterType);`
>
> - `name`:获取的方法的名称
> - `parameterType`:获取的该方法的参数的Class类型,==如果方法没有参数列表，就写null==
>   - String：`String.class`
>   - int:`int.class`
>   - 等等
>
> 调用方法：
>
> - `invoke(Object obj,Object args);`
>   - obj:要调用该方法的对象的对象名
>   - args：该方法的参数列表，==方法为无参时，写null==

```java
		//获取指定的成员方法
		Method m1 = clazz.getMethod("eat", String.class);
		//创建对象，clazz = Student.class,没有获取构造方法，所有要强制类型转换
		Student stu = (Student) clazz.newInstance();
		m1.invoke(stu, "苹果");
```



> 获取私有的成员方法
>
> `类名.class.getDeclaredMethod(String name,Class parameterType);`
>
> - `name`:获取的方法的名称
> - `parameterType`:获取的该方法的参数的Class类型,==如果方法没有参数列表，就写null==
>   - String：`String.class`
>   - int:`int.class`
>   - 等等
>
> ==因为是私有的方法，要设置访问权限才可使用==
>
> `setAccessible(true)`设置私有成员方法的访问权限

```java
		//获取私有的成员方法
		Method m2 = clazz.getDeclaredMethod("study",null);
		m2.setAccessible(true);
		m2.invoke(stu,null);
```



# 配置文件利用反射

## 配置文件

> 配置文件通过类似键值对的方式存放数据
>
> 路径通过16进制的Unicode码来表示
>
> className：表示类名
>
> - \u6848:案
> - \u4f8b:例
> - DDC：类名
> - `\u6848\u4f8b.DDC`：案例.DDC
>
> methodName:表示方法名
>
> - qi:DDC中的方法名称

```properties
className=\u6848\u4f8b.DDC
methodName=qi
```



## 类中加载配置文件

> 加载配置文件要通过IO流读取配置文件的内容
>
> `Properties`:读取配置文件的类
>
> `load（InputStream input）`：加载配置文件

```java
		Properties p = new Properties();
		InputStream input = new FileInputStream("pro.properties");
		p.load(input);
```

> 提取类路径和方法名
>
> `getProperty(String Key);`:获取配置文件中的key值
>
> - key：配置文件中的key值

```java
		String className = p.getProperty("className");
		String methodName = p.getProperty("methodName");
```

> 通过反射创建对象，调用方法

```java
		Class clazz = Class.forName(className);
		Method m = clazz.getMethod(methodName, null);
		
		m.invoke(clazz.newInstance(), null);
```



> DDC类

```java
public class DDC {
	
	public void qi() {
		System.out.println("骑电动车出去兜风");
	}	
}
```

