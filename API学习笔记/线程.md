[TOC]

# 线程

## 进程和线程

> - 一个进程中可以有多个线程
>
> - 每个进程开辟一块空间，进程中的线程不用开辟空间
>
> - 线程的执行效率，速度比进程快

1. 程序：静态的代码块
2. 进程：具有独立的内存，动态的执行过程
3. 线程：在进程内，动态的执行过程。线程可以同时运行（相对意义上的）



## 实现线程的两种方式：

> - 继承Thread类
> - 实现Runnable接口



### 继承Thread类

> - 实现步骤：
>   - 继承Thread类
>   - 重写public void run() 方法
>     - run方法也叫线程体方法，线程执行的代码放到run方法中
>   - 启动线程：start方法，由系统分配时间片，由cpu自动调用run方法
>
> `Thread.sleep(1000)`：线程休眠
>
> 线程体方法------run（）方法,==线程的执行语句必须方法run方法中，run方法不用自己调用==

```java
/**
 * 继承Thread方法
 * 	实现线程的步骤：
 * 		1.继承Thread类
 * 		2.重写public void run() 方法
 * 			run方法也叫线程体方法，线程执行的代码放到run方法中
 * 		3.启动线程：start方法，由系统分配时间片，由cpu自动调用run方法
 * @author dell
 *
 */
class MyThread extends Thread{
	//线程体方法------run（）方法,线程的执行语句必须方法run方法中，run方法不用自己调用
	@Override
	public void run() {
		for(int i = 1; i<=10;i++) {
			//进程休眠
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("MyThread");
		}
	}
	
}


class MyThread2 extends Thread{
	//线程体方法------run（）方法
	@Override
	public void run() {
		for(int i = 1; i<=10;i++) {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("MyThread2");
		}
	}
	
}

public class Demothread {

	public static void main(String[] args) {
		MyThread t1 = new MyThread();
		MyThread2 t2 = new MyThread2();
		t1.start();
		t2.start();
		
	}

}
```



> 使用匿名类实现
>
> 方法一：

```java
/**
 * 使用匿名类继承Thread创建Thread对象
 */
new Thread() {
    @Override
    public void run() {
        for(int i = 0;i<=10;i++) {
            //currentThread():获取正在执行的线程对象
            //getName() : 获取线程的名称
            System.out.println(Thread.currentThread().getName());
        }
    }
}.start();
```

> 方法二：
>
> setName(String str)：给线程起名字

```java
Thread t1 = new Thread() {
	@Override
	public void run() {
		for(int i = 0;i<=10;i++) {
			//currentThread():获取正在执行的线程对象
			//getName() : 获取线程的名称
			System.out.println(Thread.currentThread().getName());
		}
	}
};
t1.setName("线程A");
t1.start();
```



### 实现Runnable接口

> - ​	实现步骤
>
>   - 实现Runnable接口
>
>   - 重写run()方法
>
>   - 创建Thread进程对象，把实现Runnable类的对象作为Thread构造方法的参数传进去
>
>     ```java
>     MyRunnable r1 = new MyRunnable();
>     Thread t2 = new Thread(r1);
>     ```
>
>     

```java
/**
 * 实现Runnable接口
 * 	实现Runnable接口的类，不是线程类
 * 	实现线程功能，Thread（Runnable r），把是现实Runnable接口的类传进去，相当于重写Thread的run方法
 * @author dell
 *
 */
class MyRunnable implements Runnable{
	//线程体方法------run（）方法
	@Override
	public void run() {
		for(int i = 1; i<=10;i++) {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("MyRunnable");
		}
	}
}

public class Demothread {

	public static void main(String[] args) {
		MyThread t1 = new MyThread();
		MyRunnable r1 = new MyRunnable();
		Thread t2 = new Thread(r1);
		t1.start();
		t2.start();
		
	}

}
```



> 使用匿名类实现
>
> 方法一
>
> `currentThread()`:获取正在执行的线程对象
>
> `getName()` : 获取线程的名称

```java
new Thread(new Runnable() {

    @Override
    public void run() {
        for(int i = 0;i<=10;i++) {
            System.out.println(Thread.currentThread().getName());
        }

    }

}).start();
```

> 方法二
>
> `Thread (Runnable target,String name)`------第二个参数给线程起名字

```java
Thread t2 = new Thread(new Runnable() {

    @Override
    public void run() {
        for(int i = 0;i<=10;i++) {
            System.out.println(Thread.currentThread().getName());
        }

    }

},"线程B");
t2.start();
```



# 常用的线程方法

> `currentThread()`:获取正在执行的线程对象
>
> `getName()` : 获取线程的名称
>
> `join()`：线程执行顺序

1. `join()`
   - 调用`join()`方法的线程开始执行，直到执行完毕，当前线程继续执行

```java
package thread;

public class JoinThread {

    public static void main(String[] args) {
        Thread t1 = new Thread() {
            @Override
            public void run() {
                for(int i = 0;i<10;i++) {
                    System.out.println("t1");
                }
            }
        };

        Thread t2 = new Thread(new Runnable() {

            @Override
            public void run() {
                for(int i = 0;i<10;i++) {
                    if(i==4) {
                        try {
                            //join() 方法，调用join方法的线程开始执行，直到执行完毕，当前线程继续执行
                            t1.join();
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }
                    System.out.println("t2");
                }

            }
        }); 
        t2.start();
        t1.start();
    }

}
```

|                             结果                             |
| :----------------------------------------------------------: |
| t2 t2 t2 t2 ==t1 t1 t1 t1 t1 t1 t1 t1 t1 t1== t2 t2 t2 t2 t2 t2<br />t1.join()，t1调用的join，所以t1线程执行完毕，再继续执行t2 |



# 线程线程的分类

> 1. ==前台线程、后台线程==
> 2. 两种线程的创建方式完全相同
> 3. 新创建的线程默认都是前台线程
> 4. 设置当前线程为后台线程的方法：`setDaemon（true）`
> 5. 两种线程完成的功能没有区别
> 6. 两种线程不同的地方：
>    - ==前台所有线程执行完毕，不管后台线程是否执行完毕，都被强制停止==
>
> ​	



## 前台线程

```java
//前台线程
Thread rose = new Thread() {
    @Override
    public void run() {
        for(int i = 0;i<=3;i++) {
            System.out.println("jack,help me");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("扑通");
    }
};
```

## 后台线程

```java
//后台线程
Thread jack = new Thread() {
    @Override
    public void run() {
        System.out.println("You jump,I jump!");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
};

//设置后台进程
jack.setDaemon(true);

```

## 启动线程

```
rose.start();
jack.start();
```



# 线程的生命周期

> 1. 新建状态：创建线程`new Thread();`
>
>    - 可以直接进入就绪状态或者死亡状态
>
> 2. 就绪状态：`start();`
>
>    阻塞状态：可能是网络慢、sleep()、wait()方法等，这种状态结束了，重新到就绪状态
>
> 3. 运行状态：Cpu执行`run()`方法的代码
>
> 4. 死亡状态：
>
>    - 执行完run()方法------正常进入
>    - `yield()`方法------强制当前进程终止



# 线程的优先级

> 3个等级：低(1)，中(5)，高(10)，系统会自动设置优先级（5，中等优先级）
>
> 设置优先级：
>
> - `setPriority(Thread.MIN_PRIORITY)`------低优先级
> - `setPriority(Thread.MAX_PRIORITY)`------高优先级
> - `setPriority(Thread.NORM_PRIORITY)`------中等优先级
> - ==内存足够的时候，设置优先级没什么作用，只有在内存不足的时候，才会高优先级优先执行==
>
> 获取优先级：
>
> - `getPriority()`
>
> |           类型            |             等级              |  值  |
> | :-----------------------: | :---------------------------: | :--: |
> | `public static final int` |  `MAX_PRIORITY`（高优先级）   |  10  |
> | `public static final int` |  `MIN_PRIORITY`（低优先级）   |  1   |
> | `public static final int` | `NORM_PRIORITY`（中等优先级） |  5   |
>
> 



# 线程的调度

> - 不同优先级
>   - 高先执行，低后执行
> - 同优先级
>   - 先到先执行



# 线程同步

> - 起因：当多个线程操作一个共享变量，可能会出现共享变量的安全性的问题
>
> - 解决方案：一个线程把共享变量的值改变之后，其他线程再进行操作，把这样的一个操作工程叫做：线程同步
>
> - 当一个线程执行时，线程锁会把该线程锁住，直到执行完毕，解锁
> - 实现步骤：
>   - ==在操作共享变量的方法上==添加关键字：`synchronized`，只要添加关键字synchronized的方法，一个线程访问，其他线程不能访问；直到当前线程释放锁，其他线程获取锁，才可以访问共享变量

```java
package thread;

public class Bank {
	private int money = 100;
	
	public synchronized void cun(int moeny) {
		for(int i = 0;i<3;i++) {
			this.money = this.money + moeny;
			System.out.println("存入："+moeny+"余额："+this.money);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	
	public synchronized void qu(int money) {
		for(int i = 0 ;i<3;i++) {
			this.money = this.money - money;
			if (this.money>=0){
				System.out.println("取出："+money+"余额为："+this.money);
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}else {
				System.out.println("余额不足无法取出");
			}
		}
	}

}


//自定义线程类-------------------------------------------------------------

public class cunThread extends Thread {
    Bank bank;

    public cunThread(Bank bank) {
        this.bank = bank;
    }

    @Override
    public void run() {
        //每次存50
        bank.cun(50);
    }
}



public class QuThread extends Thread{
    Bank bank;

    public QuThread(Bank bank) {
        this.bank = bank;
    }

    @Override
    public void run() {
        //每次取100元
        bank.qu(100);
    }
}

//启动线程
package thread;

public class BankMain {
    public static void main(String[] args) {
        Bank bank = new Bank();
        cunThread cun = new cunThread(bank);

        QuThread qu = new QuThread(bank);

        cun.start();
        qu.start();
    }
}


```



> 方法二：同步块
>
> `synchronized (this){ 同步的代码 }` ------this代表当前同步对象

```java
public class Shop implements Runnable {

	@Override
	public void run() {
		System.out.println(Thread.currentThread()
				.getName()+"正在选衣服！");
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		synchronized (this) {
			//试衣服
			System.out.println(Thread.currentThread()
					.getName()+"正在试衣间试衣服！");
			try {
				Thread.sleep(5000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}

	}

}

package 线程;

public class ShopTest {

	public static void main(String[] args) {
		//2个人要购物
				Shop shop = new Shop();
			
				
				Thread thread = new Thread(shop, "张丽");
				Thread thread2= new Thread(shop, "李丽");
				
				thread.start();
				thread2.start();	

	}
}

```



# 线程池

> 作用：
>
> - 控制线程数量（避免因为大量的线程导致的系统崩溃）
> - 重用线程（避免频繁创建销毁线程）
>
> 概念：
>
> ​		首先创建一些线程，它们的集合称为线程池，当服务器接受到一个客户请求后，就从线程池中取出一个空闲的线程为之服务，服务完后不关闭该线程，而是将该线程还回到线程池中。
>
> 
>
> ​	在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程，
>
> ​	一个线程只能执行一个任务，但我们可以同时向一个线程池提交多个任务
>
> 1
>
> 提高效率原理：
>
> ​		现有一个集合（数组），在集合中先把线程对象放进去，如果需要线程完成工作，有集合调度线程，完成任务之后，把线程放回到线程池（集合），线程可以重复使用





> 实现类：ExecutorService
>
> - 线程池对象的创建：
>
>   `ExecutorService threadPool = Executors.newFixedThreadPool(3);//初始化3个线程对象`
>
> ```java
> ExecutorService threadPool = Executors.newFixedThreadPool(3);//初始化3个线程对象
> 		for(int i = 0;i<3;i++){
> 			Thread t = new Thread(new Runnable(){
> 				@Override
> 				public void run() {
> 					System.out.println(Thread.currentThread().getName());
> 				}
> 			});
> ```
>
> - 将任务提交给线程池
>
>   `threadPool.execute(t);//放到线程池中`
>
> - 线程池的关闭：
>
>   - `shutdown` : 只是将线程池的状态设置为SHUTWDOWN状态，正在执行的任务会继续执行下去，没有被执行的则中断------==通常会用这一个==
>   - `shutdownNow` : 将线程池的状态设置为STOP，正在执行的任务则被停止，没被执行任务的则返回
>
> 



```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class TestThreadPool {

	public static void main(String[] args) {
        
		ExecutorService threadPool = Executors.newFixedThreadPool(3);//初始化3个线程对象
        
		for(int i = 0;i<3;i++){
			Thread t = new Thread(new Runnable(){
				@Override
				public void run() {
					System.out.println(Thread.currentThread().getName());
				}
			});
            
			threadPool.execute(t);//将任务提交给线程池
		}
        
		//threadPool.shutdown();
		threadPool.shutdownNow();
	}
}
```





