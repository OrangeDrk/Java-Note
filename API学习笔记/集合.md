[TOC]

# 集合

> Collection：包含两个集合List，Set
>
> List集合的特点：有序，可重复
>
> Set集合的特点：无序，不可重复
>
> Map集合的特点：使用key=value的形式存储数据（JavaEE的常用工具类的数据结构）



> List集合的常用实现类：
>
> - ArrayList：线程不安全，效率高
> - Vector：线程安全，效率低

# ArrayList

> 查询效率高；增加，删除效率低

## 创建

> ```java
> List<String> list = new ArrayList<String>();
> ```

## 添加

> `add();`

```java
		list.add("String");
		list.add("absd");
		list.add("badsf");
		list.add(1, "张三");
```



## 遍历

> 增强for或者普通for
>
> `list.get(index);`------获取索引index处的元素

```java
		//方法一
		for(String str:list) {
			System.out.println(str);
		}
		//方法二
		for(int i = 0;i<list.size();i++) {
			System.out.println(list.get(i));
		}
```



## 修改

> `set(int index, String str);`------在索引为index处添加str元素

```java
        //修改
        list.set(2, "admin");
```

## 删除

> `remove(int index);`------删除索引为index的元素
>
> `remove(String str);`------删除第一次出现str的元素

```java
		//删除
		list.remove(0);
		list.remove("badsf");
```

## 排序

> `Collections.sort(list);`

```java
	public static void test2() {
		//给ArrayList的元素排序
		List<String> list = new ArrayList<>();
		list.add("a");
		list.add("c");
		list.add("b");
		
		//给list集合排序
		Collections.sort(list);
		
		for(String str:list) {
			System.out.println(str);
		}
		
	}
```

## 对象集合的排序

> `Collections.sort(list);`
>
> 自定义类要实现Comparable接口，重写compareTo方法
>
> 升序：`this.age-o.age`
>
> 降序：`o.age-this.age`(或者是`-(this.age-o.age)`)
>
> `this.age - o.age` = 0  表示相等

```java
	@Override
	public int compareTo(Student o) {
		//从小到大 this.age-o.age
		//this.age-o.age=0；表示两个对象相等
		return this.age-o.age;
	}	
```



## 转换成数组

> `list.toArray(new 类型[0]);`
>
> 括号里声明转换数组的数据类型

```java
		//怎么把list集合转换成数组
		String[] strArray = list.toArray(new String[0]);
```



## 把数组转换成集合

> `Arrays.asList(数组名);`

```java
		//把数组转换成集合
		String[] strs = {"we","are","students"};
		List<String> strsList = Arrays.asList(strs);
```



# LinkedList

> 使用链表的形式
>
> 增删速度比ArrayList快，查找比较慢



## 面试

> ArrayList和Vector：线程安全性的不同
>
> ArrayList和LinkedList：查询，删除和添加的效率不一样



# HashSet

> 无序的，没有索引
>
> 删除，获取不能通过索引操作
>
> 没有修改的概念
>
> 线程不同步，效率高



> 方法和List的基本一致

# HashMap

> HashTable ：不允许null键null值，线程同步
>
> HashMap : 允许null键null值，线程不同步

## 创建

> 

```java
Map<Integer,String> map = new HashMap<>();
```



## 添加、修改

> `put(key,value)`

```java
		map.put(1, "张三");
		map.put(2, "李四");
		map.put(3, "wangwu");
```



## 删除

> `remove(key)`

```java
map.remove(3);
```



## 获取值

> `get(key)`
>
> 当获取一个不存在的key-value时，返回null

```java
		String valueby1 = map.get(1);
		String valueby2 = map.get(2);
		String valueby3 = map.get(3);
```



> 循环获取map集合中的数据
>
> `Set<E> keys = map.keySet();`

```java
	//使用循环获取map集合中的数据
	public static void test2() {
		Map<String,Object> map = new HashMap<>();
		//设置key,value
		map.put("name", "张三");
		map.put("pw", "123456");
		map.put("age", "20");
		map.put("phone", "17603393007");
		map.put("Email", "zhangsan@qq.com");
		
		//获取map集合中所有的key
		Set<String> keys = map.keySet();
		for(String key:keys) {
			System.out.println(key+"="+map.get(key));
		}
		
		
	}

```



> 通过==entrySet获取Map中的数据==

```java
	//通过entrySet获取map中的数据
	public static void test3() {
		Map<String,Object> map = new HashMap<>();
		//设置key,value
		map.put("name", "张三");
		map.put("pw", "123456");
		map.put("age", "20");
		map.put("phone", "17603393007");
		map.put("Email", "zhangsan@qq.com");
		
		Set<Map.Entry<String, Object>> set = map.entrySet();
		for(Map.Entry<String, Object> entry:set) {
			System.out.println(entry.getKey()+"="+entry.getValue());
		}
	}
```

