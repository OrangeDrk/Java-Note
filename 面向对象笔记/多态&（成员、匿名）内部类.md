[TOC]

# 多态

> 简单的理解为多种形态（水：气态、液态、固态）

## 行为的多态

> 一个类型的引用在指向不同的对象时，有不同的实现------==行为的多态==
>
> ==不同的对象被造型出不同的类型，或者说同一类型的引用指向不同的对象，有不同的实现==

```java
package day07;
 
interface People{
	void cut();
}
class Cuter implements People{
 
	public void cut() {
		System.out.println("理发");
	}
}
 
class Doctor implements People{
 
    public void cut() {
        System.out.println("做手术");
    }
}
class Action implements People{
    public void cut() {
        System.out.println("表演");
    }
}
public class PolymorphicDemo01 {
    public static void main(String[] args) {
        //行为的多态
        Cuter p1 = new Cuter();
        p1.cut();
        Doctor p2 = new Doctor();
        p2.cut();
        Action p3 = new Action();
        p3.cut();
        //重写看运行期
        //重载看编译期
    }
}
 

```



## 对象的多态

> 同样一个对象被造型为不同的类型时，有不同的功能------==对象的多态==
>
> 向上造型：
>
> - 父类—>子类
>
> - 接口—>实现类

```java
package day07;
interface Teacher{
    void teach();
}
interface Worker{
    void work();
}
interface Son{
    void clean();
    void zf();
}
 
class Me implements Teacher,Worker,Son{
    public void teach() {
        System.out.println("授课");
    }
    public void work() {
        System.out.println("工作");
    }
    public void clean() {
        System.out.println("洗衣");
    }
    public void zf() {
        System.out.println("做饭");
    }
}
public class PolymorphicDemo02 {
    public static void main(String[] args) {
        //对象的多态                 
        Teacher p1 = new Me();
        p1.teach();
        Worker p2 = new Me();
        p2.work();
        Son p3 = new Me();
        p3.clean();
        p3.zf();
    }
}
 

```



## 向上造型

> - 父类型引用指向子类的对象
> - 能点出来什么，看引用类型



## 向下造型

> 成功的条件只有两个
>
> - 引用所指向的对象，就是该类型
> - 引用所指向的对象，实现了该接口
>
> ​	通过`instanceof`来判断引用是否是某种类型，instanceof返回boolean结果，强转成功的条件就是它==为true==的条件
>
> ​	建议在强转之前用`instanceof`进行判断，前提是必须要确定有关系，否则编译报错

```java
package day07;
//向下造型（难点）
/*强制类型转换（向下造型），成功的条件只有两个
 *             3.1）引用所指向的对象，就是该类型
 *             3.2）引用所指向的对象，实现了该接口
 */
public class LowerLoadDemo {
    public static void main(String[] args) {
        //声明一个Boo类型的引用
        Aoo o1 = new Boo();//向上造型
        //父类o1指向new Boo()对象
        //向上造型是大类指向小类
        //强转是小类指向大类
        //强转的类型（括号里的类型）是小类的类型
        if(o1 instanceof Boo) {
            Boo o2 = (Boo)o1;//向下造型            
        }
        
        //o1指向的对象是类型Boo
        //Boo实现了Inter1接口
        //o1可以强转成Inter1（对应的接口）
        if(o1 instanceof Inter1) {
            Inter1 o3 = (Inter1)o1;//向下造型            
        }
        if(o1 instanceof Coo) {
            Coo o4 = (Coo)o1;
        }
        //Coo o4 = (Coo)o1;//类型转换异常（语法错误）
        //ClassCastException
        System.out.println(o1 instanceof Boo);
        //true o1的实例（创建的对象）属于Boo吗？
        //属于返回true，不属于返回false
        System.out.println(o1 instanceof Inter1);
        System.out.println(o1 instanceof Coo);
    }
}
//Person p = new Student();//向上造型---相当于强制类型转换，系统默认父类大，子类小，所以把Student转换成Person类型
interface Inter1{}
class Aoo{}
class Boo extends Aoo implements Inter1{}
class Coo extends Aoo{}
 

```



# 成员内部类

> 应用率低
>
> - 类中套类，外面的成为outer外部类，里面的成为Inner内部类
> - 内部类通常只服务于外部类，对外不具备可见性
> - 内部类对象通常需要在外部类中被创建
> - ==内部类可以直接访问外部类的成员（包括私有的）==
>   - 内部类有个隐式的引用指向了创建它的外部类对象------外部类.this.

```java
package day0701;
//成员内部类的演示
 
public class InnerClassDemo {
    public static void main(String[] args) {
        Aoo a = new Aoo();
        // Boo b = new Boo();//编译错误，因为Boo不是单独的类，而是Aoo的一个成员（不是独立的）
        Coo c = new Coo();
        c.say();
    }
}
 
class Aoo{//-----Outer外部类
    private int a;
    void show() {
        Boo b = new Boo();
    }
    class Boo{//成员内部类-----Inner内部类
        void show() {
            System.out.println(a);//内部类可以直接访问外部类成员，包括私有的
            //System.out.println(this.a);//编译错误
            System.out.println(Aoo.this.a);
        }
    }
}
 
 
class Coo{
    private int age = 10;
    void say() {
        Doo d = new Doo();
        d.say();
    }
    class Doo{
        void say() {
            System.out.println("My age is :"+Coo.this.age);
        }
    }
}
 

```



# 匿名内部类

> - 如果在一段程序中需要创建一个类的对象（通常这个类需要实现某个接口或者继承某个类），而且这个对象创建后，这个类的价值也就不存在了，这个类可以不必命名，称之为：匿名内部类
> - 正常的创建对象可以随意创建，想创建多少个都可以。若想创建一个类（派生类）的对象，并且对象只被创建一次，此时该类不必命名，称之为：匿名内部类
> - 内部类中访问外面的变量，该变量在jdk1.7（含）以前，要用final修饰才能访问，1.7以后直接访问

```java
package day0701;
 
public class NstInnerClassDemo {
    public static void main(String[] args) {
        /*
         * 1）系统创建了一个Eoo的一个派生类，但是没有名字（class Aoo implements Eoo{}）
         *         （自己创建的名字）
         * 2）为该派生类创建了一个对象，名为o1（Eoo o1 = new Aoo();）
         * 3)大括号中为派生类的类体
         */
        
        //语法结构规定：
        Eoo o1 = new Eoo() {
            void test03() {
            }
            //方法体内是我们需要重写的方法
        };
        
        
        /*
         * 1.创建了Eoo的派生类，但是没有名字
         * 2.为该派生类创建了一个对象，名为o2
         * 3.大括号中为派生类的类体
         */
        Eoo o2 = new Eoo() {
            void test03() {
            }
        };
        
        
        /*
         * 1.创建了Doo的派生类，但是没有名字
         * 2.为该派生类创建了一个对象，名为o3
         * 3.大括号中为派生类的类体
         */
        Doo o3 = new Doo() {
            void test() {
                System.out.println("test()方法");
            }
            void test02() {
                System.out.println("test02()方法");
            }
        };
        o3.test();
        o3.test02();
    }
}
abstract class Doo{
    abstract void test();
    abstract void test02();
}

abstract class Eoo{
    abstract void test03();
}
 

```

