[TOC]



# 动态编译

## 应用场景

> - 可以做一个浏览器端编写Java代码，上传服务器编译和运行的在线评测系统
> - 服务器动态加载某些类文件进行编译



## 两种做法

> - 通过Runtime调用javac，==启动新的进程==去操作
>
>   ```java
>   Runtime run = Runtime.getRuntime();
>   Process process = run.exec("javac -cp d:/myjava/ HelloWorld.java");
>   ```
>
> - 通过JavaCompiler动态编译
>
>   ```java
>   public static int compileFile(String sourceFile){
>   	//动态编译
>   	JavaCompiler compiler = ToolProvider.getSystem.JavaCompiler();
>   	int result = compiler.run(null,null,null,sourceFile);
>   	System.out.println(result==0?"编译成功":"编译失败");
>   	return result；
>   }
>   ```
>
> - `compiler.run(null,null,null,sourceFile)`四个参数：
>
>   - 第一个参数：为Java编译器提供参数
>   - 第二个参数：得到Java编译器的输出信息
>   - 第三个参数：接收编译器的错误信息
>   - 第四个参数：可变参数（是一个String数组）能传入一个或多个Java源文件
>   - 返回值：0表示编译成功，非0表示编译失败

### 通过Runtime调用javac，启动新的进程去编译执行

> - ==动态编译==实例：
>
>   ```java
>   import javax.tools.JavaCompiler;
>   import javax.tools.ToolProvider;
>   
>   public class Demo01 {
>   	
>   	public static void main(String[] args) {
>   		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
>   		int result = compiler.run(null, null, null, "E:/MyJava/HelloWorld.java");
>   		System.out.println(result==0?"编译成功":"编译失败");
>   		
>   		
>   	}
>   
>   }
>   ```
>
>   - 如果程序存在于一个字符串中，可通过IO流创建一个临时的java文件，然后再通过上面的代码编译
>
> - ==动态运行==实例：
>
>   ```java
>   		Runtime run = Runtime.getRuntime();
>   		Process process = run.exec("java -cp E:/MyJava HelloWorld");
>   		InputStream in = process.getInputStream();
>   		BufferedReader reader = new BufferedReader(new InputStreamReader(in));
>   		
>   		String info = "";
>   		while((info = reader.readLine())!=null) {
>   			System.out.println(info);
>   		}
>   ```



### 通过反射运行编译好的类

> - 动态运行实例：
>
>   ```java
>   		URL[] urls = new URL[] {new URL("file:/E:/MyJava/")};
>   		URLClassLoader loader = new URLClassLoader(urls);
>   		Class clazz = loader.loadClass("HelloWorld");
>   		Method m = clazz.getMethod("main", String[].class);
>   		m.invoke(null, (Object)new String[] {});
>   		
>   		//m.invoke(null, new String[] {"a","b"});----会转换成m.invoke(null,"a","b");
>   		//public static voidmmm(String[] a,String[] b){}
>   		//public static void main(String[] arg){}
>   ```
>
> - 注：
>
>   - `m.invoke(null,(Object)new String[] {})`要对后面的new String[]{} 强制转换成(Object)
>     - 不加会把数组里的元素拆分按多个参数传递
>     - 加(Object)会按照一个对象的形式传递