[TOC]



# 反射机制

## 反射机制

> 反射机制reflection
>
> - 指的是可以于运行时加载、探知、使用编译期间完全未知的类
>
> - 程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性
>
> - `Class c = Class.forName("com.my.test.User");`
>
>   ```java
>   package TestReflection;
>   /**
>    * 测试java.lang.Class对象的获取方式
>    * @author 橙汁儿Drk
>    *
>    */
>   
>   public class Demo01 {
>   
>   	public static void main(String[] args) {
>   		String path = "TestReflection.User";
>   		
>   		try {
>   			Class<?> clazz = Class.forName(path);
>   			//对象是表示或者封装一些数据，一个类被加载后，jvm会创建一个对应类的Class对象，类
>   			//的整个结构信息会放到对应的Class对象中。
>   			//这个Class对象就像一面镜子，通过这面镜子可以看到对应类的全部信息
>   			System.out.println(clazz);
>   			System.out.println(clazz.hashCode());
>   			
>   			Class clazz2 = Class.forName(path);//一个类只对应一个Class对象
>   			System.out.println(clazz2.hashCode());
>   			
>   		} catch (Exception e) {
>   			e.printStackTrace();
>   		}
>   	}
>   }
>   
>   ```
>
>   
>
> - 加载完类之后，在堆内存中，就产生了一个Class类型的对象（==一个类只有一个Class对象==），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射

## 动态语言

> - ==程序运行时，可以改变程序结构或变量类型==；典型语言：Python、ruby、JavaScript等
>
> - 如下的JavaScript代码
>
>   ```javascript
>   function test(){
>   	var s = "var a = 3; var b = 5;alert(a+b);"；
>       eval(s);
>   }
>   ```
>
> - C,C++,Java不是动态语言，但是Java有一定的动态性，我们可以利用反射机制、字节码操作获取类似动态语言的特性
>- Java的动态性让编程的时候更灵活



## 获取到Class对象

> 1. ==通过路径获取Class对象==
>
>    `Class clazz = Class.forName(path);`
>
> 2. ==通过类名获取Class对象==
>
>    `Class strClazz = String.class;`
>
> 3. ==通过已存在的对象获取Class对象==
>
>    `Class strClazz2 = path.getClass();`
>
> 4. 数组的Class对象
>
>    - ==相同维的数组，Class对象相等；数组类型不同，Class对象不同==
>
>      ```java
>      int[] arr01 = new int[10];
>      int[] arr02 = new int[20];
>      System.out.println(arr01.getClass().hashCode());
>      System.out.println(arr02.getClass().hashCode());
>      ```
>
>      结果两个hashCode相等：
>
>      > 1311053135
>      > 1311053135
>
>    - ==不同维的数组，Class对象不相同，hashCode也不相同==
>
>      ```java
>      int[] arr02 = new int[20];
>      int[][] arr03 = new int[20][];
>      
>      System.out.println(arr02.getClass().hashCode());
>      System.out.println(arr03.getClass().hashCode());
>      ```
>
>      结果两个hashCode不相等：
>
>      > 1311053135
>      > 118352462



# 反射的各种操作

## 动态加载类、动态获取类的信息

> 前提：通过路径获取Class对象
>
> `Class clazz = Class.forName(path);`



### 获取类的名字

> - 获得包名+类名：`clazz.getName()`
> - 获得类名：`clazz.getSimpleName()`

### 获取属性信息

> - 只能获得public修饰的field：`clazz.getFields()`
> - 获得所有修饰符的field：`clazz.getDeclaredFields()`
> - 获取指定名称的field：`clazz.getDeclaredField("name")`

### 获取方法信息

> - 获取public修饰的Method：`clazz.getMethods()`
> - 获取所有的Method：`clazz.getDeclaredMethods()`
> - 获取指定名称的Method：
>   - 无参的方法：`clazz.getDeclaredMethod("getName", null)`
>   - 有参的方法：`clazz.getDeclaredMethod("setName", String.class)`

### 获取构造器信息

> - 获取public修饰的构造器：`clazz.getConstructors()`
> - 获取所有的的构造器：`clazz.getDeclaredConstructors()`
> - 获取指定参数的构造器：
>   - 无参构造器：`clazz.getDeclaredConstructor(null)`
>   - 有参构造器：`clazz.getDeclaredConstructor(int.class,int.class,String.class)`



## 动态构造对象

> - 通过无参构造创建对象：`User u =(User) clazz.newInstance()`
>
> - 通过有参构造创建对象：
>
>   ```java
>   Constructor<User> c = clazz.getDeclaredConstructor(int.class,int.class,String.class);
>   User u1 = c.newInstance(10,10,"小王");
>   ```
>
>   



## 动态调用对象的任意方法

> 前提：有一个对象：`User u3 =(User) clazz.newInstance()`

### 调用普通方法

> - 通过反射获取方法：`Method method = clazz.getDeclaredMethod("setName", String.class)`
> - 调用方法：`method.invoke(u3, "小高");`



## 动态调用和处理属性

> 前提：有一个对象：`User u4 =(User) clazz.newInstance()`
>
> - 通过反射获取属性：`Field f = clazz.getDeclaredField("name")`
> - ==设置私有属性的访问权限==：`f.setAccessible(true);`
> - 对指定对象的该属性设置值：`f.set(u4, "小王")`
> - 通过反射读对象该属性的值：`f.get(u4)`
>
> 



## 获取泛型信息

> 1. Java采用==泛型擦除的机制==来引入泛型。
>
>    - Java中的泛型仅仅是给编译器javac使用的，==确保数据的安全性和免去强制类型转换的麻烦==
>    - 一旦编译完成，所有的==和泛型相关的类型全部擦除==
>
> 2. 为了通过==反射操作这些类型==以迎合实际开发的需要
>
>    - Java新增了ParameterizedType、GenericArrayType、TypeVariable和WildcardType几种类型来==代表不能被归一到Class类中的类型但是又和原始类型齐名的类型==
>
> 3. 类型：
>
>    - ParameterizedType：表示一种参数化的类型，比如Collection<String>
>
>    - GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型
>
>    - TypeVariable：是各种类型变量的公共父接口
>
>    - WildcardType：代表一种通配符类型表达式
>
>      - 比如：？、？extends Number、？super Integer
>
>      - 【wildcard是一个单词，意思是：通配符】
>
> 
>
> 
>
> 
>
> 



## 处理注解

> `clazz.getAnnotations()`:Annotation[]
>
> ==参考Annotation注解最后==



# 反射机制性能问题

> - `setAccessible(Boolean b)`
>   - 启用和禁用安全检查的开关
>     - true：不检查，可操作私有属性和方法
>     - false：检查，不可操作私有属性和方法
>   - ==禁用安全检查，可以提高反射的运行速度（true）==