# 目录
[单例模式](#单例模式)



# 单例模式

> - 核心作用：
>   - 保证一个类只有一个实例，并且提供一个访问该实例的全局访问点
> - 常见应用场景
>   - ==Windows的Task Manager==（任务管理器）就是很典型的单例模式
>   - ==Windows的Recycle Bin==（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护者仅有的一个实例
>   - ==项目中，读取配置文件的类==，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取
>   - ==网站的计数器==，一般也是采用单例模式实现的，否则难以同步
>   - ==应用程序的日志应用==，一般都用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加
>   - ==数据库连接池的设计==一般也是采用单例模式，因为数据库连接是一种数据库资源
>   - ==操作系统的文件系统==，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统
>   - ==Application== 也是单例的典型应用（Servlet编程中会涉及到）
>   - ==在Spring中，每个Bean默认就是单例的==，这样做的优点是Spring容器可以管理
>   - ==在Servlet编程中，每个Servlet也是单例==
>   - ==在Spring MVC框架/struts1框架中，控制器对象也是单例==
> - 单例模式的优点
>   - 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永远驻留内存的方式来解决
>   - 单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理



## 常见的五种单例模式实现方式

> - 主要
>   - ==饿汉式==（**线程安全，调用效率高。不能延迟加载**）
>   - ==懒汉式==（**线程安全，调用效率不高，可以延迟加载**）
> - 其他
>   - ==双重检测锁式==（**由于JVM底层内部模型原因，偶尔会出问题，不建议使用**）
>   - ==静态内部类式==（**线程安全，调用效率高可以延迟加载**）
>   - ==枚举单例==（**线程安全，调用效率高，不能延迟加载**）

### 饿汉式(单例对象立即加载)

> - 饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略`synchronized`关键字
>
> - 问题：如果只是加载本类，而不是要调用getInstance()，甚至永远没有调用，则会造成资源浪费
>
> - 代码例子：
>
>   ```java
>   package testsingleton;
>   //singleton---单例
>   
>   /**
>    * 测试饿汉式单例模式
>    * @author 橙汁儿Drk
>    *
>    */
>   public class SingletonDemo01 {
>   
>   	//类初始化时，立即加载这个对象（没有延迟加载的优势）。加载类时，天然的是线程安全的
>   	private static SingletonDemo01 instance = new SingletonDemo01();
>   	
>   	private SingletonDemo01() {//私有化构造器
>   		
>   	}
>   	
>   	//方法没有同步，调用效率高，
>   	public static SingletonDemo01 getInstance() {
>   		return instance;
>   	}
>   }
>   
>   ```



### 懒汉式(单例对象延迟加载)

> - 要点：
>
>   - lazy load！(延迟加载，懒加载)，真正用的时候才加载
>
> - 问题：
>
>   - 资源利用率高了，但是，每次调用`getInstance()`方法都要同步，并发效率较低
>
> - 代码例子：
>
>   ```java
>   package testsingleton;
>   
>   /**
>    * 测试懒汉式单例模式
>    * @author 橙汁儿Drk
>    *
>    */
>   public class SingletonDemo2 {
>   
>   	//类初始化时，不初始化这个对象（延迟加载，真正用的时候再创建）。
>   	private static SingletonDemo2 instance;
>   	
>   	private SingletonDemo2() {//私有化构造器
>   		
>   	}
>   	
>   	//方法同步，调用效率低。
>   	public static synchronized SingletonDemo2 getInstance() {
>   		if (instance == null) {
>   			instance = new SingletonDemo2();
>   		}
>   		return instance;
>   	}
>   }
>   
>   ```
>
>   

